#
#This file contains the infastructure for tetris repurposed for Gaz
#



def rotate_clockwise(shape):
    '''rotates the shape clockwise around [0][0]
    '''
    return [ [ shape[y][x]
               for y in xrange(len(shape)) ]
             for x in xrange(len(shape[0]) - 1, -1, -1) ]

def check_collision(board, shape, offset):
        off_x, off_y = offset
        for cy, row in enumerate(shape):
                for cx, cell in enumerate(row):
                        try:
                                if cell and board[ cy + off_y ][ cx + off_x ]:
                                        return True
                        except IndexError:
                                return True
        return False

def join_matrixes(mat1, mat2, mat2_off):
        off_x, off_y = mat2_off
        for cy, row in enumerate(mat2):
                for cx, val in enumerate(row):
                        mat1[cy+off_y-1 ][cx+off_x] += val
        return mat1

class Row(list):
	def __init__(self, row):
		list.__init__(self, row)
		self.is_full = all(row)

class Column(list):
	def __init__(self, col_list):
		list.__init__(self, col_list)
		self.height_gap = False
		self.height = False
		self.spaces = False

	def __eq__(self, other_col_list):
		return self == other_col_list

	def remove_space(self, index):
		if index in range(len(self)):
			del self[index]
			return [0] + self
		return self

	def calc_data(self, update=False):#calculates or updates data
		if not self.height_gap or update:
			self.calc_height_gap()
		if not self.height or update:
			self.height = len(self) - self.height_gap
		if not self.spaces or update:
			self.spaces = self.count(0) - self.height_gap
		return self

	def calc_height_gap(self):
		for i,j in enumerate(self):
			if j != 0:
				self.height_gap = i
				break

class Board(list):
	def __init__(self, board_list):
		if isinstance(board_list, Board):
			self = board_list
		else:
			list.__init__(self, [Column(col).calc_data() for col in board_list])

		self.max = False
		self.min = False
		self.average = False
		self.mode = False
		self.total_spaces = False
		self.full_rows = False
		self.row_completeness = False

	def invert(self):
		return [list(row) for row in zip(*self)]
	
	def calc_data(self, update=False):		
		if not self.full_rows or self.row_completeness or update:
			self.full_rows = 1
			self.row_completeness = 1

			row_board = self.invert()							#get the board in row format
			if len(row_board[0]) == cols:							#when the board isn't a slice
				for index, row in enumerate(row_board[:-1:-1]):				#loop through each row bottom first

					perc_complete = float(len(row) - row.count(0)) / len(row)       #get the percent complete of the row
					row_complete = perc_complete / (index + 1)                      #the lower the row is more complete the higher the score
					self.row_completeness += row_complete
				
				for index, row in enumerate(row_board[:-1:-1]):
					if all(row):							#if the row is complete
						for col in self:col.remove_space(index)			#delete that space in each column
						self.full_rows += 1 					#increment the number of rows

				self.row_completeness /= rows
					
		if not self.max or update:
			self.max = max(col.height for col in self)
		if not self.min or update:
			self.min = min(col.height for col in self)
		if not self.average or update:
			self.average = sum(col.height for col in self)/len(self)
		if not self.mode or update:
			heights = [col.height for col in self]
			self.mode = max(heights, key=heights.count)
		if not self.total_spaces or update:
			self.total_spaces = sum(col.spaces for col in self)
		return self

	def data(self):
		print "Max: %d" % (self.max)
		print "Avg: %f" % (self.average)
		print "Mode: %d" % (self.mode)
		print "Spaces: %d" % (self.total_spaces)
		print "Rows: %d" % (self.full_rows)
		print "Comp: %f" % (self.row_completeness)

	def calc_col_data(self):
		for col in self:
			col.calc_data(True)

	def slice_iter(self, width):#iterator that returns a "board" object

		assert 1 <= width <= len(self)

		for col in range(0, len(self) - width + 1):
			yield (col, Board(self[col:col+width][:]))

	def fake_add(self, x, piece):#takes a piece at an x coordinate and returns a board object with that piece "insta dropped"
		row_board = self.invert()								#get the board in col format
 
		assert x in [0]+range(len(self) - len(zip(*piece)) + 1)					#make x coord is within bounds
		
		for y in range(1, len(row_board)):							#loop through index's of row_board
			if check_collision(row_board, piece, (x, y)):					#if there is a collision at "y"
				row_board_with_piece = join_matrixes(row_board, piece, (x, y))		#add the piece to the board
				return Board(zip(*row_board_with_piece))				#return new Board in original format
